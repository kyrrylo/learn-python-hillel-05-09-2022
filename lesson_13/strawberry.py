from plant import Plant
from math import floor


class Strawberry(Plant):
    def __init__(self, berries_count: float = 0.0):
        """
        Метод инициализации класса Клубника определяет поля/атрибуты класса:
            - присваиваем все поля/атрибуты класса-предка (некоторые поля имеют константное, а не переменное значение)
            - добавляем свои поля/атрибуты
        :param berries_count: сколько ягод изначально на кустике
        """
        # superior - стоящий выше по иерархии
        # вызов метода инициализации класса предка обязателен
        # вызов других методов класса предка - по необходимости
        super(Strawberry, self).__init__(name="Клубника", speed=0.005, max_days=60)
        self.__berries_count = berries_count

        # __*имя* - private, недоступные извне класса атрибуты

    # setter для атрибута days
    def set_days(self, days):
        """
        Сеттер-метод, который позволяет назначить значение приватной переменной
            это делается для того, чтобы любые изменения, связанные с этой переменной,
            вступили в силу и не поломали работу программы

        Ответственной этого метода/функции - гарантировать то, что изменение переменной days
        не повлечёт логических ошибок (чего нельзя гарантировать если эту переменную просто менять посреди кода)

        Это пример работы принципа Инкапсуляции (защищённости системы от неправомерных случайных изменений)
        :param days: новое значение количества дня
        """
        self._days = 0
        self._height = 0
        self.__berries_count = 0
        self.to_grow = True
        self.grow(days)

    # getter для атрибута days
    def get_days(self):
        """
        Метод/функция, сообщающая значение приватной переменной __days и не дающая возможности её неправомерно изменять
        :return:
        """
        return self._days

    def __str__(self):
        """
        Служебный метод, вызывающийся при каждом print(objname), str(objname)
        и любом другой явной и неявной конвертации объекта класса в строку (str)

        То что метод служебный, можно понять из обрамления двойными подчёркиваниями __ (и цвет в PyCharm)

        Пример действия полиморфизма - есть метод в Plant и в Strawberry, у них одна ответственность, название,
        точки вызова, но разная логика подготовки результата
        (Strawberry дополнительно включает в себя информацию о ягодах)

        :return: текстовое описание объекта класса
        """
        # вызов других методов класса предка - по необходимости
        s = super(Strawberry, self).__str__()
        if self.to_grow:
            s += f". Есть {floor(self.__berries_count)} ягод"
            return s
        return s

    def grow(self, days):
        """
        Выполняет ту же функцию, что и класс-предок Plant, дополняя её своей: растут еще и ягоды
        :param days: на сколько дней подросло
        """
        # вызов других методов класса предка (не инициализации) - по необходимости
        super(Strawberry, self).grow(days)
        if self.to_grow:
            self.__berries_count += days * 0.5
